---
show: true
collection: D3.js Concept
collectionOrder: 6
cover: D3-concept.png
tags:
  - D3.js
  - data-vis
---

# 数据处理与分析
参考：

* [Arrays (d3-array)](https://github.com/d3/d3/blob/main/API.md#arrays-d3-array)
* [d3-array](https://github.com/d3/d3-array)（非官方[中译版](https://github.com/xswei/d3-array)）

本文主要介绍 ==Arrays 模块==

在前端数据可视化中，数据集一般以 JavaScript 的可迭代对象 iterable 的形式存储，如[数组 array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)、[集合 set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)、[映射 map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)、[generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator) 等，所以 D3 提供了 d3-array 模块有丰富的方法用于处理这些可迭代对象，可以在 JavaScript 中进行初步的数据分析。

:bulb: 在使用该模块前，应该熟悉 JavaScript 中与数组 Array 相关的的[内置方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)，因为 d3-array 模块的一些方法是借鉴了数组的内置方法并进行扩展的。

## 统计分析
以下方法可以计算关于数据集的一些基本统计量

* `d3.min(iterable[, accessor])` 获取数据集中的最小值。如果可迭代对象中包含不可比较的元素，则该方法返回 `undefined`

  :bulb: 与 JavaScript 内置的 `Math.min()` 方法不同，该方法忽略值为 `undefined`、`null`、`NaN` 的元素。

  第一个参数 `iterable` 是可迭代对象，即数据集。

  第二个参数是访问器，它是一个函数。可迭代对象在进行对比寻找最小值前，**每个元素都会调用一次访问器，并以该元素作为入参，最后将返回代表该元素，再用返回值进行对比**。它类似于 `arr.map()` 或 `Array.from()`。

  ```js
  // 先将字符串转换为数值，再求最小值
  d3.min(["2", "3", "10"], s => +s)
  ```

  :bulb: `d3.min()` 对比两个元素所采用的顺序是 natural order，因此如果数据集的元素是字符串，会依次对字符串中的字符进行[对比](https://zh.javascript.info/string#bi-jiao-zi-fu-chuan)，对比采用的是数字代码（所有的字符串都使用 UTF-16 编码，可以通过方法 `str.codePointAt(0)` 获取字符串第 `0` 位置上的字符的字符代码）

  ```js
  console.log("20".codePointAt(0)); // 50
  console.log("3".codePointAt(0)); //51

  const stringArr = ["20", "3"];
  d3.min(stringArr); // "20"

  const numberArr = [20, 3];
  d3.min(numberArr); // 3
  ```

  :bulb: 如果希望**获取最小值在可迭代对象中的位置，即索引**，可以使用方法 `d3.minIndex(iterable[, accessor])`，如果可迭代对象中包含不可比较的元素，则该方法返回 `-1`。

* `d3.max(iterable[, accessor])` 和 `d3.maxIndex(iterable[, accessor])` 分别用于获取可迭代对象中的最大值和相应的索引

* `d3.extent(iterable[, accessor])` 获取可迭代对象的范围，即返回一个由最小值和最大值构成的数组 `[min, max]`，如果可迭代对象中包含不可比较的元素，则该方法返回 `[undefined, undefined]`

* `d3.mean(iterable[, accessor])` 获取可迭代对象的平均值。如果可迭代对象中没有数值类型的元素，则返回 `undefined`

* `d3.mode(iterable[, accessor])` 获取可迭代对象的众数。如果有多个出现频率相同的元素，返回索引较前的那一个。

* `d3.sum(iterable[, accessor])` 获取可迭代对象所有元素之和。如果可迭代对象中没有数值类型的元素（如果字符串仅由数字构成也算作数值，因为在运算时可以隐式转换为数值），则返回 `0`

* `d3.cumsum(iterable[, accessor])` 获取可迭代对象的累计求和 cumulative sum 数组，其中返回的数组的元素是 64 位精度的浮点数值 Float64Array。如果可迭代对象中包含非数值元素，则该元素看作是 `0`。数组的长度与可迭代对象的长度一致。

  ```js
  d3.cumsum([1, 2, 3, 4]); // Float64Array(4) [1, 3, 6, 10]

  d3.cumsum([1, "2", "c", undefined]); // Float64Array(4) [1, 3, 3, 3]
  ```

* `d3.fsum([values][, accessor])` 获取可迭代对象所有元素之和。和 `d3.sum()` 作用相同，但是结果更精准（虽然运算时间比较慢），因为其内部不是使用 JavaScript 的 `+` 操作符，而是使用 D3 的**加法器**，它使得结果精度符合 [IEEE 754 浮点数算术标准](https://en.wikipedia.org/wiki/IEEE_754)。

  ```js
  d3.fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]); // 1
  d3.sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]); // 0.9999999999999999
  ```

  :bulb: D3 提供了一个加法器，通过 `new d3.Adder()` 创建一个加法器（以下称为 `add`），其初始值是 `0`，通过该加法器执行数值运算，可以让结果精度符合 [IEEE 754 浮点数算术标准](https://en.wikipedia.org/wiki/IEEE_754)。

  * `adder.add(number)` 将数值 `number` 与加法器当前的值相加

  * `adder.valueOf()` 返回加法器当前的值，也可以使用 `+adder` 获取

* `d3.fcumsum([values][, accessor])` 获取可迭代对象的累计求和。和 `d3.cumsum()` 作用相同，但是结果更精准。

  ```js
  d3.fcumsum([1, 1e-14, -1]); // [1, 1.00000000000001, 1e-14]

  d3.cumsum([1, 1e-14, -1]); // [1, 1.00000000000001, 9.992e-15]
  ```

* `d3.median(iterable[, accessor])` 获取可迭代对象的中位数。如果可迭代对象中没有数值类型的元素，则返回 `undefined`

* `d3.quantile(iterable, p[, accessor])` 获取可迭代对象的分位数。

  第一个参数 `iterable` 是可迭代对象，即数据集。

  第二个参数 `p` 是需要获取的分位数，范围在 $[0, 1]$ 之间。例如需要获取中位数（即第 2 个四分位数 Q2），则 `p=0.5`；需要获取第 1 个四分位数 Q1 ，则 `p=0.25`；需要获取第 3 个四分位数 Q3，则 `p=0.75`；如果 `p=0` 或 `p=1` 则分别获取可迭代对象中第一个元素和最后一个元素。

  第三个参数是访问器。

  :bulb: 以上方法传入的可迭代对象并不要求是有序的，因为每次都会对可迭代对象进行排序并求出范围；如果**原始数据已经是有序**的，则可以调用性能更佳的方法 `d3.quantileSorted(array, p[, accessor])`，它不会再进行排序操作，执行速度更快。具体区别可以查看[源码](https://github.com/d3/d3-array/blob/main/src/quantile.js)。

* `d3.variance(iterable[, accessor])` 获取可迭代对象的[方差](http://mathworld.wolfram.com/SampleVariance.html)。如果可迭代对象中数值类型的元素少于 2 个，则返回 `undefined`

* `d3.deviation(iterable[, accessor])` 获取可迭代对象的标准差。如果可迭代对象中数值类型的元素少于 2 个，则返回 `undefined`

## 排序与检索
* `d3.rank(iterable[, comparator])` 或 `d3.rank(iterable[, accessor])` 对可迭代对象的元素进行排序，**返回一个表示排序值的数组**。默认采用**升序排列 ascending**，所以返回的数组中的每一个元素（一个索引值）就表示该位置所对应的元素在排序中的序号。

  第一个参数 `iterable` 是可迭代对象，即数据集。

  第二个（可选）参数可以是 `accessor` 访问器或 `comparator` 对比器，它们都是函数，但是作用不同：

  * **访问器 `accessor` 接收一个参数** `d`，即当前遍历的可迭代对象的元素，其返回值代表该元素，用于进行对比

  * **对比器 `comparator` 接收两个参数** `a, b`，即当前遍历的可迭代对象的元素，以及下一个需要和它进行对比的元素。在函数内设置这两个元素的对比规则。
  **返回的值可以是 `-1`（或负数）、`0`、`1`（或正数），分别表示这两个元素的排序的不同先后关系**，如果返回值是 `-1` 就将 `a` 元素置于 `b` 元素前；如果返回值是 `1` 就将 `a` 元素置于 `b` 元素后；如果返回是 `0` 则保持 `a` 元素与 `b` 元素的相对位置不变。

  :bulb: 对于 Nullish 空值类型的元素，会被排到最后，并统一分配一个非数值序号 `NaN`

  :bulb: 如果希望采用降序排列 descending，可以传递内置的对比函数 `d3.descending`

  ```js
  // 返回的数组 [1, NaN, 2, 0] 表示在升序排列中各元素的应该位于哪个位置：
  // 元素 {x: 1} 所对应的索引值是 1，应该位于第 2 位
  // 元素 {} 所对应的索引值是 NaN，应该位于最后
  // 元素 {x: 2} 所对应的索引值是 2，应该位于第 3 位
  // 元素 {x: 0} 所对应的索引值是 0，应该位于第 1 位
  d3.rank([{x: 1}, {}, {x: 2}, {x: 0}], d => d.x); // [1, NaN, 2, 0]

  // 对于字符串也可以进行排序
  // 依次对比字符串的字符，对比时采用的是字符的数字代码（所有的字符串都使用 UTF-16 编码）
  d3.rank(["b", "c", "b", "a"]); // [1, 3, 1, 0]

  // 采用降序排列
  d3.rank([1, 2, 3], d3.descending); // [2, 1, 0]
  ```

* `d3.least(iterable[, comparator])` 或 `d3.least(iterable[, accessor])` 获取可迭代对象的最小值。

  它和 `d3.min()` 作用相同，区别在于该方法可以设置对比器 `comparator` 自定义元素的对比方式，默认以升序排序，并取第一个元素。

  ```js
  const array = [{foo: 42}, {foo: 91}];
  // 设置对比器
  // 升序（默认）
  d3.least(array, (a, b) => a.foo - b.foo); // {foo: 42}
  // 降序
  d3.least(array, (a, b) => b.foo - a.foo); // {foo: 91}

  // 设置访问器
  d3.least(array, a => a.foo); // {foo: 42}
  ```

  如果可迭代对象中没有数值类型的元素，则返回 `undefined`

  :bulb: 如果希望**获取最小值的索引**，可以使用方法 `d3.leastIndex(iterable[, comparator])` 或 `d3.leastIndex(iterable[, accessor])`，它和 `d3.minIndex()` 作用相同，区别在于该方法可以设置对比器 `comparator`。如果可迭代对象中包含不可比较的元素，则该方法返回 `-1`。

* `d3.greatest(iterable[, comparator])` 或 `d3.greatest(iterable[, accessor])` 获取可迭代对象的最大值。

  :bulb: 如果希望**获取最大值的索引**，可以使用方法 `d3.greatestIndex(iterable[, comparator])` 或 `d3.greatestIndex(iterable[, accessor])`

* `d3.ascending(a, b)` 对比两个参数 `a` 和 `b` 的大小，基于大小关系返回不同的值。

  它的源码如下

  ```js
  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  ```

  * 如果 `a` 小于 `b` 则返回 `-1`
  * 如果 `a` 大于 `b` 则返回 `1`
  * 如果 `a` 等于 `b` 则返回 `0`

  **一般该方法会作为默认的对比器 comparator**，用于排序操作中。由于**返回的值的正负是用来决定元素 `a` 和 `b` 最终排列顺序**，如果返回值为负值，则元素 `a` 位于元素 `b` 前面；如果返回值为正值，则元素 `a` 位于元素 `b` 后面；如果返回值是 `0`，则元素 `a` 和元素 `b` 的相对位置不变。所以以上规则，最后会将较小值排在前面，较大值排在后面，即**升序排列**

* `d3.descending(a, b)` 也是基于参数 `a` 和 `b` 的大小关系返回不同的值，和方法 `d3.ascending(a, b)` 规则正好相反，所以将它作为对比器 comparator 时，获得的是**降序排序**。

* `d3.quickselect(array, k[, left[, right[, compare]]])` 快速选择出数组中最小的 `k+1` 个元素（由于数组元素的索引值从 `0` 开始），并**在原数组里 in place** 对部分元素调整了位置，使得返回的数组中，左侧元素是最小的 `k+1` 个元素。

  :warning: 最后返回的数组并**不是**整个都有序。

  第一个参数 `array` 是数组，即数据集

  第二个参数 `k` 称为间隔索引 middle index 或指针索引 pivot index。返回的数组中，在该索引左侧的元素都小于（或等于）右侧的元素

  第三、四个（可选）参数用以设置数组的分片（包括左右索引所指的元素），仅对该分片的元素进行操作

  第五个（可选）参数用于设置对比器 comparator

  ```js
  const numbers = [16, 15, 18, 10, 17, 14, 13, 19, 11, 12];
  // 返回的数组并不是整个都有序
  // 只是确保前两个元素是最小的
  d3.quickselect(numbers.slice(), 2);// [11, 10, 12, 15, 13, 14, 16, 17, 18, 19]

  const input = [0, 4, 1, 6, 7, 5, 8, 2, 9, 3];
  // 从数组的第 5 个（索引为 4）元素到第 9 个（索引为 8）元素进行查询
  // （针对整个数组而言）间隔索引是 6
  // 即对于索引值为 [4, 8] 范围内的元素进行查询，选出两个较小的值
  // 可以查看网页 https://observablehq.com/@d3/d3-quickselect#cell-405 所提供的可视化演示
  d3.quickselect(input.slice(), 6, 4, 8); // [0, 4, 1, 6, 2, 5, 7, 8, 9, 3]
  ```

  :bulb: 该方法比数组的 `arr.sort()` 方法性能更佳，执行速度更快，一般用于获取分位数，而不需要返回一个有序的数组。具体的原理可以查看[这里](https://github.com/mourner/quickselect/blob/master/README.md)。

## 分割
有时候需要基于特定值，**将（有序）的数组里的元素一分为二**，D3 提供了以下方法实现该需求：

* `d3.bisectLeft(array, x[, lo[, hi]])` 返回索引值 index，如果将 `x` 插入到该位置（可以使用数组的 `arr.splice()` 方法），依然保持数组有序。

  第一个参数 `array` 是（有序）数组，即数据集

  第二个参数 `x` 待插入到数组的值

  第三、第四（可选）参数用于指定数组的片段，待插入值 `x` 只会与该片段的元素进行对比。其中 `lo` 表示 lower 即下限，`hi` 表示 high 即上限

  如果数组中已经存在与 `x` 相同的元素，则将 `x` 插入到该元素的**左侧**，因此**保证了在索引左侧的元素都小于 `x`**，即 $v < x$（其中 $v$ 是表示在数组 $[lo, i]$ 范围中的元素）；在索引右侧的元素都大于或等于 `x`，即 $v \ge x$（其中 $v$ 是表示在数组 $[i, hi]$ 范围中的元素）

* `d3.bisect(array, x[, lo[, hi]])` 或 `d3.bisectRight(array, x[, lo[, hi]])` 也是返回索引值 index，以插入 `x` 到数组中。不过在数组中已经存在与 `x` 相同的元素时，将 `x` 插入到该元素的**右侧**，因此**保证了在索引右侧的元素都大于 `x`**

* `d3.bisectCenter(array, x[, lo[, hi]])` 返回索引值 index，索引所指的元素与 `x` 的「距离」最近。

除了以上方法 D3 提供了方法 `d3.bisector(accessor)` 或 `d3.bisector(comparator)` 创建**通用**的分割器（以下称为 bisector），将数组按照一定条件一分为二。

分割器有相应的「左分割」、「右分割」、「临近分割」等方法：

* `bisector.left(array, x[, lo[, hi]])` 左分割，和 `d3.bisectLeft()` 作用相同，区别在于该方法可以设置访问器 `accessor` 或对比器 `comparator`，这样分割器可以适用于数组的元素数据类型为较复杂（例如对象）的情况

* `bisector.right(array, x[, lo[, hi]])` 右分割，和 `d3.bisect()` 或 `d3.bisectRight()` 作用相同

* `bisector.center(array, x[, lo[, hi]])` 临近分割，和 `d3.bisectCenter()` 作用相同

```js
// 数组的元素是复杂的数据类型（对象）
const data = [
  {date: new Date(2011, 1, 1), value: 0.5},
  {date: new Date(2011, 2, 1), value: 0.6},
  {date: new Date(2011, 3, 1), value: 0.7},
  {date: new Date(2011, 4, 1), value: 0.8}
];

// 创建一个分割器，并设置 accessor 访问器，返回元素的属性 date 作为对比值
const bisector = d3.bisector(function(d) { return d.date; })

// 采用右分割
const bisectDate = bisector.right(data, new Date(2011, 3, 15));

// 也可以设置 comparator 对比器
// const bisector = d3.bisector(function(d, x) { return d.date - x; });
```

