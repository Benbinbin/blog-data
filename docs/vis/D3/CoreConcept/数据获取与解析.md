---
show: true
collection: D3.js Concept
collectionOrder: 2
cover: D3-concept.png
tags:
  - D3.js
  - data-vis
---

# 数据获取与解析

参考：

* [Learn D3: Data](https://observablehq.com/@d3/learn-d3-data?collection=@d3/learn-d3)
* [Fetches (d3-fetch)](https://github.com/d3/d3/blob/main/API.md#fetches-d3-fetch)（非官方[中译版](https://github.com/xswei/d3-fetch)）
* [d3-dsv](https://github.com/d3/d3-dsv)（非官方[中译版](https://github.com/xswei/d3-dsv)）
* [Time Formats (d3-time-format)](https://github.com/d3/d3/blob/main/API.md#time-formats-d3-time-format)



本文主要介绍 ==Fetches 模块==

进行数据可视化的第一步是需要获取数据，可以使用 JS 提供的 File API [读取](https://developer.mozilla.org/en-US/docs/Web/API/FileReader)用户在表单 `<input type="file">` 中主动导入的本地文件，或者通过发送[网络请求](https://developer.mozilla.org/en-US/docs/Web/HTTP)获取在线数据。

D3 的 d3-fetch 模块封装了 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)，除了可以获取在线数据以外，还针对常见的数据格式，例如 CSV、TSV、JSON、XML 等，提供强大的解析功能。

在模块中提供以下方法：

* `d3.blob(url, requestInit)` 获取二进制文件并解析为 Blob

  * 第一个入参是数据文件的路径
  * 第二个（可选）参数是[网络请求的额外配置](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)

  ```js
  const data = await d3.blob("/path/to/file");
  ```

* `d3.buffer(url, requestInit) ` 获取二进制文件并解析为 ArrayBuffer

* `d3.json(url, requestInit)` 获取 JSON 文件，如果返回的响应状态码是 `204` [No Content](https://developer.mozilla.org/docs/Web/HTTP/Status/204) 或 `205` [Reset Content](https://developer.mozilla.org/docs/Web/HTTP/Status/205) 则 Promise 会 resolve `undefined`

* `d3.text(url, requestInit)` 获取文本文件

* `d3.dsv(delimiter, url, requestInit, row)` 获取 DSV 文件

  :bulb: DSV 是 Delimiter Separated Values 的简称，是一类文件格式的统称，在这些文件存储着二维数据，每一行是一个数据项，每个数据项中各值之间使用**特定的符号分隔**，例如 `.csv` 后缀的文件使用逗号分隔 [Comma-separated values](https://en.wikipedia.org/wiki/Comma-separated_values)，`.tsv` 后缀的文件使用 Tab 键（制表键）分隔 [Tab-separated values](https://en.wikipedia.org/wiki/Tab-separated_values)

  * 第一个入参是指定分隔符

  * 第二个入参是数据文件的路径

  * 第三个（可选）参数是一个对象，用以设置网络请求的额外配置

  * 第四个（可选）参数是是一个函数，**行数据转换和筛选函数**。 ==如果没有指定转换和筛选函数，则解析得到的数据的值类型是**字符串**。==

    入参是数据项（依然传递一行数据到函数中），该函数就像为每一行的数据应用数组的 [`map` 函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)和 [`filter` 函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)，对数据进行转换和筛选，如果返回 `null` 或 `undefined` 则该行数据就会被忽略跳过

    :bulb: 其实该方法在内部调用的是 ==[d3-dsv 模块](https://github.com/d3/d3-dsv)==所提供的诸多方法（该模块主要用于**解析和构建 DSV 类型文件**，但没有封装 fetch 功能），例如 `dsvFormat(delimiter)` 用于构建一个通用的 DSV 解析器，它有很多实用方法；`d3.csvParse()` 是专门用于解析 CSV 数据的解析器，等价于 `d3.dsvFormat(",").parse`；`d3.csvFormat()` 是专门用于构建 CSV 数据的构建器，等价于 `dsvFormat(",").format`。

    :bulb: 推荐自己按照数据的特点和需求创建**转换和筛选函数**，但显式地声明数据类型在列属性较多时是很繁琐的，需要罗列出各列的数据类型。有时候为了方便也可以使用 D3 **[数据类型的自动推断](https://github.com/d3/d3-dsv#autoType)**的功能，可以将 D3 内置的转换函数 `d3.autotype` 传递给 fetch 模块或 d3-dsv 模块中的相应方法，例如  `d3.dsv(',', url, d3.autotype)`、`d3.csv(url, d3.autotype)`、`d3.csvParse(d3.autotype)`，这样 D3 就会自动将数据从字符串类型转换为推断的数据类型。:warning: 应该及时查看验证转换结果，因为自动类型推断有可能「[失灵](https://observablehq.com/@d3/d3-autotype)」，特别是对于数据复杂的情况。

  ```js
  const data = await d3.dsv(",", "test.csv", (d) => {
    //
    return {
      year: new Date(+d.Year, 0, 1), // 将数据项中 Year 的数据转换为 JS 的 Date 对象格式
      make: d.Make, // 将数据项中 Make 的数据映射到属性 make
      model: d.Model, // 将数据项中 Model 的数据映射到属性 model
      length: +d.Length // 将数据项中 Length 的数据从字符串格式转换为数值形式
    };
  });
  ```


* `d3.csv(url, requestInit, row)` 获取 CSV 文件，相对于 `d3.dsv(',', url, init, row)`

* `d3.tsv(url, requestInit, row)` 获取 TSV 文件，相对于 `d3.dsv('\t', url, init, row)`

* `d3.html(url, requestInit)` 获取文本文件，并解析为 HTML

* `d3.image(url, requestInit)` 获取图片文件，如果希望实现匿名跨源请求可以进行如下配置

  ```js
  const img = await d3.image("https://example.com/test.png", {
      crossOrigin: "anonymous"
  });
  ```

* `d3.svg(url, requestInit)` 获取文本文件，并解析为 SVG

* `d3.xml(url, requestInit)` 获取文本文件，并解析为 XML



D3 还专门提供了一个模块 [d3-time-format](https://github.com/d3/d3-time-format) 用于解析和构建时间数据。

为了将时间对象格式化为特定的模式，需要使用 `d3.timeFormat(specifier)` 构建一个时间格式器，入参 `specifier` 是一个字符串，它由一系列[以 `%` 为前缀的指令](https://github.com/d3/d3-time-format#locale_format)构成。然后使用该时间格式器格式化时间对象

```js
const formatTime = d3.timeFormat("%B %d, %Y"); // %B 表示月份（全称），%d 是以数值表示的日，%Y 表示年
formatTime(new Date("2021/11/4")); // "November 04, 2021"
```

为了解析特定模式的时间数据，需要使用 `d3.timeParse(specifier)` 构建一个时间解析器，入参也是一个 `specifier` 字符串

```js
const parseTime = d3.timeParse("%B %d, %Y");
parseTime("November 04, 2021"); // Thu Nov 04 2021 00:00:00 GMT+0800 (中国标准时间)
```

