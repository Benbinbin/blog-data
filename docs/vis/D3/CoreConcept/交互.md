---
show: true
collection: D3.js Concept
collectionOrder: 5
cover: D3-concept.png
tags:
  - D3.js
  - data-vis
---

# 交互

参考：

* [Learn D3: Interaction](https://observablehq.com/@d3/learn-d3-interaction?collection=@d3/learn-d3)
* [Brushes (d3-brush)](https://github.com/d3/d3/blob/main/API.md#brushes-d3-brush)
* [Zooming (d3-zoom)](https://github.com/d3/d3/blob/main/API.md#zooming-d3-zoom)
* [Dragging (d3-drag)](https://github.com/d3/d3/blob/main/API.md#dragging-d3-drag)
* [d3-brush](https://github.com/d3/d3-brush)（非官方[中译版](https://github.com/xswei/d3-brush)）
* [d3-zoom](https://github.com/d3/d3-zoom)（非官方[中译版](https://github.com/xswei/d3-zoom)）
* [d3-drag](https://github.com/d3/d3-drag)（非官方[中译版](https://github.com/xswei/d3-drag)）

本文主要介绍 ==Brushes、Zooming 和 Dragging 模块==

图表交互有**两面性**，它可以让阅读者探索数据，以更多的角度来理解数据；但是过于自由的探索，也可能让用户忽略数据的某些重要的信息。因此对于可交互的图表设计需要更用心，应该在图表的初始状态给予足够的引导和提示。而如果只是想提供图表说明传达已知的信息，则选择静态的图表会更高效。

对于交互图表的设计，Ben Shneiderman 给出了一个很好的[指南](https://www.cs.umd.edu/~ben/papers/Shneiderman1996eyes.pdf)：

> Overview first,
zoom and filter,
then details on demand.

* 总览 overview 是图表的初始状态，应该展现数据的整体视图，以引导用户对数据的特定部分进行探索
* 缩放 zoom 和筛选 filter 是探索的手段，通过[平移](https://observablehq.com/@d3/pannable-chart)、[缩放](https://observablehq.com/@d3/zoomable-area-chart)、[聚焦筛选](https://observablehq.com/@d3/zoomable-area-chart)、[刷选](https://observablehq.com/@d3/brushable-scatterplot-matrix)等方法选择所感兴趣的部分数据进行探索
* 细节按需显示 details on demand 是在读者希望知道特定的数据时，才通过 tooltips 等方式显示，这样可以保证图表的准确性

## 刷选
Brushing 刷选是在一维或二维空间对于区域进行选择的一种交互方式，通过鼠标的指针在点击后拖拽框选出一个特定的区域，常见的一个例子在[散点图](https://observablehq.com/@d3/brushable-scatterplot-matrix)中刷选特定区域中的多个数据点，以进行局部研究。

d3-brush 模块通过监听在 SVG 上的鼠标（拖拽）或触摸事件来实现刷选操作。此外还可以提供更丰富的操作，如默认支持在选区内点击并拖拽以移动选区、通过点击移动选区的一边可以改变选区的大小、通过点击并拖拽（选区外）透明的覆盖层可以创建一个新的选取、按住 `Alt` 键可以从中间等距向四周扩张创建选区。而且还可以通过调用相应的方法，[以编程式创建选区和移动选区](https://observablehq.com/@d3/brush-snapping-transitions)

### 创建刷选器
d3-brush 模块提供三种的方法创建不同功能的刷选器（以下称为 `brush`）：

* `d3.brush()` 创建一个二维空间的刷选器

* `d3.brushX()` 创建一个 X 轴刷选器

* `d3.brushY()` 创建一个 Y 轴刷选器

刷选器既是一个方法，它接受选择集（一般是一个 `<g>` 元素构成的选择集）作为入参，然后刷选器可以针对选择集中的元素（即该元素/容器 `<g>`）设置相应的事件监听器

```js
svg.append("g")
    .attr("class", "brush")
    .call(d3.brush().on("brush", brushed));
    // 一般通过 selection.call() 方法调用刷选器创建函数
    // 这样 selection 选择器就会作为参数传递给刷选器创建函数
```

以上示例中，刷选器为选择集中的元素添加（D3 所定义的拖拽事件类型）`brush` 事件监听器，并设置了相应的处理函数 `brushed`（一般在回调函数中设置元素的样式，以区分未选中和选中的元素，也会执行其他操作）

:bulb: 如果希望移除刷选相关事件的监听器，可以为将相应事件回调函数设置为 `null`

```js
group.on(".brush", null);
```

刷选器会创建一系列 SVG 元素以展示选区，并响应用户的刷选操作。这些元素都添加了相应的类名，可以通过特定的类名来为这些元素设置不一样的样式。

```html
<!-- 一个二维空间刷选器所创建的元素 -->
<g class="brush" fill="none" pointer-events="all" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
  <!-- 具有类名 .overlay 元素覆盖在整个可刷选区域-->
  <rect class="overlay" pointer-events="all" cursor="crosshair" x="0" y="0" width="960" height="500"></rect>
  <!-- 具有类名 .selection 元素覆盖在选区 -->
  <rect class="selection" cursor="move" fill="#777" fill-opacity="0.3" stroke="#fff" shape-rendering="crispEdges" x="112" y="194" width="182" height="83"></rect>
  <!-- 具有类名 .handle 放置在选区的不同位置，它们修改了该区域的鼠标样式，以便提示用户在选区的不同区域可以进行不同的交互 -->
  <rect class="handle handle--n" cursor="ns-resize" x="107" y="189" width="192" height="10"></rect>
  <rect class="handle handle--e" cursor="ew-resize" x="289" y="189" width="10" height="93"></rect>
  <rect class="handle handle--s" cursor="ns-resize" x="107" y="272" width="192" height="10"></rect>
  <rect class="handle handle--w" cursor="ew-resize" x="107" y="189" width="10" height="93"></rect>
  <rect class="handle handle--nw" cursor="nwse-resize" x="107" y="189" width="10" height="10"></rect>
  <rect class="handle handle--ne" cursor="nesw-resize" x="289" y="189" width="10" height="10"></rect>
  <rect class="handle handle--se" cursor="nwse-resize" x="289" y="272" width="10" height="10"></rect>
  <rect class="handle handle--sw" cursor="nesw-resize" x="107" y="272" width="10" height="10"></rect>
</g>
```

:bulb: 实际上刷选操作与响应都是在这个元素 `<g>` 上进行的（并不是真的与页面的数据点元素进行交互）。它作数据点上所添加的覆盖层/容器（其覆盖范围大小通过方法 `brush.extent()` 设置），用以响应用户刷选操作，获取选区的坐标范围，然后再将获取得到的选区的坐标范围可以与数据点的坐标进行对比，再为数据点元素设置不同的样式，通过这种**间接**的方式，最后实现数据的选区效果。

使用方法 `d3.brushSelection(node)` 获取[当前的刷选区域](https://observablehq.com/@d3/double-click-brush-clear)，一个表示选区坐标范围的数组，在选择集中节点内部（`<g>` 容器）会有属性 `element.__brush` 记录着它的刷选状态

### 操作刷选区
刷选器也是一个对象，具有多种方法来增删、修改选区：

* `brush.move(group, selection[, event])` 设置选区
  * 第一个参数 `group` 是需要刷选的选择集（一般其中含有一个 `<g>` 元素/容器）
  * 第二个参数 `selection` 表示选区，它可以是数组或 `null`（无选中的元素）

    如果是二维空间的刷选器，则数组格式是 `[[x0, y0], [x1, y1]]` 以表示选区的横纵坐标范围；如果是 X 轴刷选器，则数组格式是 `[x0, x1]` 以表示选中的横坐标范围；如果是 Y 轴刷选器，则数组的格式是 `[y0, y1]` 以表示选中的纵坐标轴范围

    :bulb: 它也可以是一个返回数组或 `null` 的函数，以便根据不同的情况动态生成选区。该函数会被选择集中的每一个元素调用，并依次传入两个参数：

      * 当前所遍历的元素绑定的数据 datum `d`
      * 当前所遍历的元素在选择集合中的索引 index `i`

      而函数内的 `this` 指向当前所遍历的元素节点

* `brush.clear(group[, event])` 用于清除选区，和 `brush.move(group, null)` 作用一样

* `brush.extent([extent])` 用于设置可刷选区域。刷选器会在该区域创建一个 `<rect class="overlay" ...>` 元素作为覆盖层，响应用户的刷选操作。

  其（可选）参数 `extent` 是一个数组，格式为 `[[x0, y0], [x1, y1]]`

  :bulb: 入参也可以是一个返回数组的函数，以便根据不同的情况动态生成可刷选区域，它也是会被选择集中的每一个元素调用，并依次传入两个参数。

  :bulb: 如果没有设置可刷选区域，采用 SVG 的大小范围作为默认的区域

  ```js
  function defaultExtent() {
    var svg = this.ownerSVGElement || this;
    if (svg.hasAttribute("viewBox")) {
      svg = svg.viewBox.baseVal;
      return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
    }
    return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
  }
  ```

* `brush.filter([filter])` 用于判断是否执行刷选操作。参数 `filter` 是一个返回布尔值的函数，当返回的是 falsy 时忽略刷选操作。它用以限制特定条件下不响应刷选操作。

  参数 `filter` 的默认值如下，因此按下 `Ctrl` 时默认在可刷选区域内是**无法进行刷选操作**，因为配合键盘按键的点击操作可能有其他用途

  ```js
  function filter(event) {
    return !event.ctrlKey && !event.button;
  }
  ```

* `brush.touchable([touchable])` 判断浏览器是否支持触控操作，参数 `touchable` 是一个返回布尔值的函数，只有返回值为 truthy 时，才会在选择集的元素注册响应的触控刷选事件监听器

  参数 `touchable` 的默认值如下

  ```js
  function touchable() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
  }
  ```

* `brush.keyModifiers([modifiers])` 以设置刷选时是否同时监听键盘按键。参数 `modifiers` 是一个布尔值，默认为 `true`，这时刷选器除了监听鼠标操作，还会监听键盘按键操作，例如在刷选时同时按下 `Alt` 键，这会构建一个**从中间向四周同时**扩展的选区（这和很多图形编辑软件的选择工具的操作逻辑类似）。

* `brush.handleSize([size])` 设置选区中各个操作柄 handle 大小，默认大小为 `6`

  :warning: 该方法需要在刷选器与选择集进行绑定**之前**调用

* `brush.on(typenames[, listener])` 为选择集中的元素（`<g>` 容器）设置刷选相关事件的监听器。

  第一个参数 `typenames` 是需要监听的刷选相关事件，D3 提供了 3 种刷选相关事件类型：
    * `start` 刷选开始时（如鼠标按下操作）所触发的事件
    * `brush` 刷选过程中（如鼠标移动操作）所触发的事件
    * `end` 刷选结束时（如松开按键操作）所触发的事件

  :bulb: 可以在事件后添加名称 `name` 并用 `.` 分隔，如 `brush.on('brush.foo', listener)`，这样就可以为通过一个刷选事件类型添加多个不同的处理函数

  :bulb: 如果希望移除刷选相关事件的监听器，可以为将相应事件回调函数设置为 `null`

  ```js
  brush.on(".brush", null);
  ```

  第二个参数 `listener` 是事件处理函数，它会在相应的刷选类型事件触发时被调用，而且依次接收与当前刷选事件相关的 5 个参数：

  * `target` 当前触发刷选事件的刷选器
  * `type` 当前的刷选类型，可以是 `start`、`brush` 或 `end`
  * `selection` 当前的选区，一个表示刷选区域的坐标范围的数组
  * `mode` 当前刷选的模式，可以是 `drag`（移动选区）、`space`（按住空格键移动选区）、`handle`（通过框选创建选区，也可能时通过拖动选区的四个角或四条边来调整选区） 或 `center`（按住 `Alt` 键创建选区）