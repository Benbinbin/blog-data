---
show: true
collection: D3.js Concept
collectionOrder: 6
cover: D3-concept.png
tags:
  - D3.js
  - data-vis
---

# 数据绑定

参考：

* [Learn D3: Joins](https://observablehq.com/@d3/learn-d3-joins?collection=@d3/learn-d3)
* [Shapes (d3-shape)](https://github.com/d3/d3/blob/main/API.md#selections-d3-selection)
* [d3-selection](https://github.com/d3/d3-selection)（非官方[中译版](https://github.com/xswei/d3-selection)）
* [How Selections Work](https://bost.ocks.org/mike/selection/)（演示代码使用 d3.js [版本是 v3](https://github.com/d3/d3/releases/tag/v3.0.0)）
* [Nested Selections](https://bost.ocks.org/mike/nest/)（演示代码使用 d3.js [版本是 v2](https://github.com/d3/d3/releases/tag/v2.0.0)）
* [Thinking with Joins](https://bost.ocks.org/mike/join/)（演示代码使用 d3.js [版本是 v4](https://github.com/d3/d3/releases/tag/v4.0.0)）
* [selection.join](https://observablehq.com/@d3/selection-join)（演示代码使用 d3.js [版本是 v6.7.0](https://github.com/d3/d3/releases/tag/v6.7.0)）

本文主要介绍 ==Selections 模块==

D3 框架的核心是**使用数据驱动 DOM 元素**，所以在项目中经常需要将数据与视觉元素（一般是SVG 元素）进行**绑定 join**，主要使用 [d3-selection 模块](https://github.com/d3/d3-selection)提供的各种方法实现，然后数据会添加到 DOM 元素的 `__data__` 属性中，这样特定的数据就和特定的元素「结合」在一起了（即使清空了选择集，再次重新选择元素，也可以读取到原来绑定的数据）。

## 选择元素
要将数据绑定到 DOM 元素上，第一步是要选中需要操作的 DOM 元素，D3 的 d3-selection 模块提供了多种方法来**选择**元素，它们一般都会返回一个**选择集（以下称为 `selection`）**

* `d3.selection()` 选中**页面的根元素**，选择集中只有一个元素 `document.documentElement`，即 `<html>` 元素。

  :bulb: 该方法还可以用来判断一个变量是否为选择集（类型 class） `varName instanceof d3.selection`

  :bulb: 也可以用于为选择集的原型 prototype 上方法，实现功能的增强，这样在之后的所有选择集上都可以调用新增的方法

  ```js
  // 为选择集添加一个 checked 的方法
  // 它接收一个可选参数，用于为选择集中的元素（复选框）设置选中状态；如果没有传入参数，则返回当前的选中状态
  d3.selection.prototype.checked = function(value) {
  return arguments.length < 1
      ? this.property("checked")
      : this.property("checked", !!value);
  };
  ```

  ```js
  // 调用选择集的 checked 方法
  d3.selectAll("input[type=checkbox]").checked(true);
  ```

* `d3.select(selector)` 在整个网页中选中**第一个匹配的元素**（匹配顺序基于 DOM 文档结构顺序），参数 `selector` 是表示 CSS 选择器的字符串，返回只有一个或空元素（如果没有匹配的元素，则为空）的选择集

  :bulb: 如果**参数直接就是一个 DOM 元素 node，则直接选中该元素**，这一般用于 D3 的一些方法的回调函数中，因为这些回调函数的 `this` 一般都是指向当前遍历的 DOM 元素

  ```js
  // 为所有段落设置点击事件监听器
  d3.selectAll("p").on("click", function(event) {
    // 将当前被点击的段落字体颜色设置为红色
    d3.select(this).style("color", "red");
  });
  ```

* `d3.selectAll(selector)` 在整个网页中选中**所有匹配的元素**，如果 `selector` 参数是 `null` 或 `undefined` 或没有匹配的元素，则返回一个空选择集

  :bulb: 如果**参数直接就是一个包含 DOM 元素 nodes 的数组，则直接选中这些元素**，例如 `elemName.childNodes` 选中某个元素的所有子元素，`document.links` 选中页面的所有锚标签元素

  ```js
  d3.selectAll(document.links).style("color", "red");
  ```

* `selection.select(selector)` 针对一个选择集 `selection` 的每一个元素，分别在它的**后代元素**中选中第一个匹配的元素，并返回由这些选中元素所构成的新选择集。如果原来选择集中的各个元素都绑定了相应的数据，则这些数据会**传递给新选择集中相应的元素**。

  :bulb: 入参 `selector` 可以是一个返回元素或 `null` 的函数，则原选择集中的每个元素都会调用一次该函数，且依次传入三个参数，这样的选择器有更大的自由度：
  * 当前元素所绑定的数据 datum `d`
  * 当前元素在组中的索引 index `i`
  * 所在组的元素 `nodes`（原选择集可能是由多个组 group 构成的）

  该函数内部的 `this` 就是当前的元素 `nodes[i]`

  :bulb: 如果入参 `selector` 是 `null`，则返回的新选择集中，每个元素都会是 `null`，即一个空选择集

  :warning: 该方法更新选择集的元素，但是并**不会**影响选择集的分组情况，包括元素在选择集的分组中的索引次序，各分组的父节点，新选择集中各元素「继承」了相应的绑定数据

  :bulb: 如果在当前元素的后代元素中没有找到匹配的元素时，那么就会以 `null` 来表示（相当于占位符）

  ```js
  const divSelection = d3.selectAll("div").data([1, 2, 3]);

  console.log("divSelection：", divSelection);

  // 基于选择集 divSelection 进行「二次选择」
  // 从选择集 divSelection 的每个 <div> 元素的后代元素中，选中第一个 <p> 元素，并将它的字体颜色设置为红色
  const subSelection = divSelection.select("p").style("color", "red");

  console.log("subSelection：", subSelection);
  ```

  :hammer: 在 [CodePen](https://codepen.io/benbinbin/pen/yLzbarM) 查看代码效果，下图是控制台输出的结果

  ![selection-select](./images/selection-select.png)

  可以查看相应元素所绑定的数据，可以知道数据从原选择集「传递」到新选择集的相应元素

  ![selection-select-data](./images/selection-select-data.gif)

* `selection.selectAll(selector)` 也是针对一个选择集 selection 的每一个元素进行「二次选择」，但是该方法是选中**后代元素**中所有匹配的元素，并返回由这些选中元素所构成的新选择集。

  :warning: 该方法**为原选择集中各元素创建一个分组，且该元素作为该组的父节点**，然后其后代元素被选中的，就作为该组的元素（如果入参 `selector` 为 `null`，或没有匹配的元素，该分组依然被保留，只是其中元素为空）。由于后代元素中匹配条件的可能有多个，所以原来选择集中的各个元素都绑定了相应的数据，**并不会**传递给新选择集中的元素（如果希望为新选择集的元素绑定数据，可以使用方法 `selection.data()` 手动绑定新数据；原来的数据依然绑定在原来的元素上，即在父节点数组 `_parents` 中）

  :bulb: 入参 `selector` 也可以是一个返回（包含多个元素或为空的）数组的函数，可以让选择器有更大的自由度，例如返回的不是该元素的后代元素，而是可以为兄弟元素

  ```js
  // 选择页面的所有 <p> 元素
  // 然后基于该选择集，分别为各 <p> 元素创建一个分组
  // 选中各个 <p> 元素的前后兄弟元素作为各分组的元素
  const sibling = d3.selectAll("p").selectAll(function() {
    return [
      this.previousElementSibling,
      this.nextElementSibling
    ];
  });
  ```

  由于调用该方法会**更新分组**，所以得到的新选择集和原选择集的分组并不相同。

  ```js
  const divSelection = d3.selectAll("div").data([1, 2, 3]);

  console.log("divSelection：", divSelection);

  // 基于选择集 divSelection 进行「二次选择」
  // 为选择集 divSelection 的每个 <div> 元素创建一个分组
  // 选中每个 <div> 元素的所有后代元素 <p> 元素，作为相应分组的元素，并将它们的字体设置为红色
  const subSelection = divSelection.selectAll("p").style("color", "red");

  console.log("subSelection：", subSelection);
  ```

  :hammer: 在 [CodePen](https://codepen.io/benbinbin/pen/zYEwZPw?editors=1010) 查看代码效果，下图是控制台输出的结果

  ![selection-selectAll](./images/selection-selectAll.png)

  可以查看相应元素所绑定的数据，可以知道数据从原选择集「传递」到新选择集的相应元素

  ![selection-selectAll-data](./images/selection-selectAll-data.gif)

* `selection.selectChild([selector])` 也是针对一个选择集 `selection` 的每一个元素进行「二次选择」，但是该方法是选中**直接子元素**中第一个匹配的元素。如果调用该方法时省略了参数 `selector` 则选择第一个直接子元素。

  :bulb: 类似于方法 `d3.select()`

  :bulb: 入参 `selector` 也可以是一个函数，则原选择集中的（每个分组中的）每个元素的**子元素**都会调用一次该函数，且依次传入三个参数，当函数的返回值为真 truthy 的时候，则选中该子元素。可以让选择器有更大的自由度：
  * 当前遍历的子元素 `child`
  * 当前遍历的子元素在其父元素中的索引 index `i`
  * 当前遍历的子元素所在的父元素，其所有子元素 `children`

* `selection.selectChildren([selector])` 也是针对一个选择集 `selection` 的每一个元素进行「二次选择」，但是该方法是选中**直接子元素**中所有匹配的元素。如果调用该方法时省略了参数 `selector` 则选择所有子元素。

  :bulb: 类似方法 `d3.selectAll()`

  :bulb: 入参 `selector` 也可以是一个函数

D3 还有一些对选择集进行「二次操作」的方法，用以构建出新的选择集：

* `selection.filter(filter)` 对一个选择集 `selection` 进行二次筛选。

  :bulb: 该方法一般是**对选择集的元素直接进行筛选**，而方法 `selection.select()` 和 `selection.selectAll()` 一般是**对选择集元素的后代元素进行筛选**。当然也可以使用函数作为入参，构建更通用的筛选条件。

  入参 `filter` 可以是一个表示 CSS 选择器的字符串，该方法的作用和 `d3.selectAll()` 类似

  ```js
  // 选择表格的偶数行
  const even = d3.selectAll("tr").filter(":nth-child(even)");

  // 类似于以下方法
  const even = d3.selectAll("tr:nth-child(even)");
  ```

  入参 `filter` 也可以是函数，则选择集中的每个元素都会调用该函数，而且依次传入三个参数，当函数返回值为 truthy 真的时候，该元素会被选中到新选择集里：
    * 当前所遍历的元素所绑定的数据 datum `d`
    * 当前所遍历的元素在其分组中的索引次序 index `i`
    * 当前分组中的所有元素 `nodes`

    函数的 `this` 指向当前遍历的元素，即 `nodes[i]`

  :warning: 该方法不会改变选择集的分组（父节点信息得以保留），但是由于该方法和 `Array.filter()` 方法类似，**会将不符合条件的元素被筛掉了**，所以新选择集中的元素的**索引一般会改变**；如果希望新筛选得到的元素（在分组内）[索引（与原选择集索引相比）不变](https://codepen.io/benbinbin/pen/XWeRGQb)，可以使用 `selection.select()` 方法，因为当元素的后代元素匹配为空时，会使用 `null` 作为占位符

  ![selection-select-vs-filter](./images/selection-select-vs-filter.png)

  :bulb: D3 提供了一个方法 `d3.matcher(selector)` 用以创建匹配器。调用它生成一个函数，函数内部的 `this` 指向当前的遍历的元素，如果 `this` 所指向的元素和入参 `selector`（表示 CSS 选择器的一个字符串）匹配的话，函数就返回 `true`

  它一般在以上的 `d3.filter()` 方法的内部使用

  ```js
  const div = selection.filter(d3.matcher("div"));

  // 等价于以下操作
  const div = selection.filter("div");
  ```

* `selection.merge(otherSelection)` 将两个选择集合并，返回的新选择集和原选择集 `selection` **有相同的分组 `_groups` 且分组的父节点 `_parents` 也一样**。

  :warning: 所以两个合并的选择集**一般都有相同的分组和父节点**，如果 `otherSelection` 中有其他分组和父节点，而 `selection` 不具备的，这些分组会被忽略。

  :bulb: 实际上该方法不是用于合并任意两个选择集的，而是**一般在 `selection.join()` 内部调用**，（在绑定数据后）用以合并 updating 选择集和 entering 选择集；当然也可以调用该方法，手动合并两个选择集，但是应该注意合并后元素的顺序受原选择集中元素的索引顺序影响，因此构建原选择集的操作，应该是可以保留元素索引次序，如应该使用 `selection.select()` 方法进行「二次选择」，而不应该使用 `selection.filter()` 方法。如果在 `selection` 和 `otherSelect` 选择集中的相同索引位置都具有元素，则取 `selection` 选择集的元素作为合并后新选择集该位置的元素。

  ```js
  const odd = selection.select(function(d, i) { return i & 1 ? this : null; ));
  const even = selection.select(function(d, i) { return i & 1 ? null : this; ));
  const merged = odd.merge(even);
  ```

  :bulb: 入参也可以是 `transition` 实际也是与 `transition.selection()` 返回的选择集进行合并

除了选择元素，D3 还提供了一个方法 `d3.window(node)` 用以方便地基于目标节点 `node` 获取它所在的窗口对象 `window`

```js
const node = document.getElementById("section");
console.log(node);

const win = d3.window(node);
console.log(d3.window(node));
win.alert("hello");
```

### 选择器工作原理
通过调用以上 D3 提供的多种选择器，可以得到相应的选择集，它类似于数组，但并**不是**直接包含选中的元素，而是**先包含了一系列的分组 `_groups`**，再在每个分组中包含相应的一系列匹配条件而被选中的元素。

```mermaid
graph TD
  selection --> group1
  selection --> group2
  selection --> group...

  group1 --> elem1
  group1 --> elem2
  group1 --> elem...
```

:bulb: 而且选择集还具有属性 `_parents` 用以记录各分组的父节点 parentNode 信息。

:bulb: 此外在选择集的原型 prototype 上还有一系列类似数组的方法，方便我们对选择集进行操作，例如 `selection.sort()` 对选择集的元素进行排序。

以下是 `d3.selection()` 返回的选择集的结构示意图

```mermaid
graph LR
  selection --> group --> html
```

可以在控制台打印出该选择集：
* 属性 `_groups` 中具有一个分组，其中只有一个元素 `<html>` 即页面的根元素
* 属性 `_parents` 包含了各组相应的父节点，由于唯一的分组（具有一个元素是根节点 `<html>`）没有父节点，所以是空 `null`
* 原型 prototype 列出了多种选择集特有的方法，它们一般会返回所操作的选择集，便于进行**链式**调用

![selection-prototype](./images/selection-prototype.png)

一般情况下，选择集中都只有一个分组，除非进行了[**嵌套选择** Nested Selections 操作](https://bost.ocks.org/mike/nest/)，即使用了 `selection.selectAll()` 方法生成的选择集。

例如使用 `d3.selectAll('td')` 选中页面的所有表格单元格（假设页面只有一个表格，且该表格是一个 4x4 表格），以下图示为选择集的结构，该选择集只有一个分组，由于使用方法 `d3.selectAll()` 所以该分组的父节点是页面的根元素 `<html>` 然后该分组内包含了 16 个 `<td>` 元素

![flatten-select](./images/flatten-select.png)

如果采用**嵌套选择**方式，先选中表格的各行，然后对选择集进行「二次选择」，再分别选中各行的单元格 `d3.selectAll('tr').selectAll('td')` 以下图示为选择集的结构，该选择集有四个分组，每个分组的父节点都是相应的行，每个分组内的元素都是相应行的单元格

![nest-select](./images/nest-select.png)

使用以 `selection.selectAll` 进行嵌套选择时，**分组**会变动。**它会为原选择集中的每个元素创建一个分组，然后将各元素被选中的后代元素作为该分组的元素**，以下[动图](https://bost.ocks.org/mike/selection/)演示了该过程

![nest-select-animate](./images/nest-select-animate.gif)

可以进行多次嵌套选择，例如再进一步选择所有单元格内的 `<span>` 元素

![sub-nest-select-animate](./images/sub-nest-select-animate.gif)

:bulb: 选择集的方法一般都适用于具有单个或多个分组的情况，而且调用选择集方法一般都相同（除了 `selection.data(data)` 当选择集只有一个分组时，入参是一个数组；当选择集具有多个分组时，需要传递的是一个返回数组的函数），D3 在这些方法内部会自动分组依次执行。

以上多种选择元素的方法，按照选择元素的数量，分为两大类：

* `select` 为后缀的方法，最多选择一个元素（按照 DOM 文档的顺序，选中第一个匹配的元素）
* `selectAll` 为后缀的方法，选择所有匹配的元素

以上多种选择元素的方法，按照适用场景不同

* 上述选择元素的方法中，以 `d3` 为前缀的方法，其返回的选择集中只有一个分组 group，且都是以页面的根元素 `<html>` 作为父节点 parentNode
* 从选择集中进行二次选择的方法 `selection.select(selector)` **分组不变**，即各组的父节点不变
* 从选择集中进行二次选择的方法 `selection.selectAll(selector)` **会更新分组**，依据原选择集的每个元素创建作为一个分组，且这些元素分别作为各自组的父节点

| 方法 | 分组（父节点） | 适用范围 |
| :--: | :--: | :--: |
| `d3.selection()` | 一个分组（`null`） | 选择页面的根节点 `<html>` |
| `d3.select(selector)` | 一个分组（`<html>`） | 选择页面第一个匹配条件 `selector` 的元素 |
| `d3.selectAll(selector)` | 一个分组（`<html>`） | 选择页面所有匹配条件 `selector` 的元素 |
| `selection.select(selector)` | 和原选择集分组一样（不变） | 基于原选择集的元素，在各元素的后代元素中进行二次选择，各元素都替换为一个匹配条件 `selector` 的后代元素 |
| `selection.selectAll(selector)` | 为原选择集的每个元素创建一个分组（原选择集的各元素作为各分组的父节点） | 基于原选择集的元素，在各元素的后代元素中进行二次选择，各分组包含所有匹配条件 `selector` 的后代元素 |
| `selection.selectChild([selector])` | 和原选择集分组一样（不变） | 基于原选择集的元素，在各元素的直接子元素中进行二次选择，各元素都替换为一个匹配条件 `selector` 的子元素 |
| `selection.selectChildren([selector])` | 为原选择集的每个元素创建一个分组（原选择集的各元素作为各分组的父节点） | 基于原选择集的元素，在各元素的直接子元素中进行二次选择，各分组包含所有匹配条件 selector 的子元素 |
| `selection.filter(filter)` | 和原选择集分组一样（不变） | 对原选择集的元素进行二次选择 |
| `selection.merge(otherSelection)` | 和原选择集分组一样（不变） | 合并两个选择集，一般在数据绑定后用于合并 updating 选择集和 entering 选择集 |

## 修改属性
选择集的原型 prototype 上有很多方法，有一部分是用来修改元素的样式 style、特性 attribute 或属性 property 以便对元素进行各种设置与变换

:bulb: 这些方法一般都还会返回当前操作的选择集，便于进行**链式**调用：

* `selection.attr(name[, value])` 为选择集中的元素添加值为 `value` 名字为 `name` 的特性。其中 `value` 参数可以是一个常量值；也可以是一个返回值的函数，该函数会被每一个元素调用，并依次传入三个参数（选择集的其他方法如果支持传入函数作为参数，一般也都是依次传入这三个参数）：
  * 当前所遍历的元素所绑定的数据 datum `d`
  * 当前所遍历的元素在其分组中的索引 index `i`
  * 当前所遍历的元素其所属分组的所有元素 `nodes`

  而函数内的 `this` 指向当前遍历的元素，即 `nodes[i]`

  :bulb: 如果 `value` 为 `null` 将移除该元素的 `name` 特定

  :bulb: 如果没有传入参数 `value` 则返回选择集中第一个具有属性 `name` 的属性值，一般是在选择集中只有一个元素时才这么用

  :bulb: 参数 `name` 可以具有命名空间前缀，例如 `xlink:href` 用以设置 `<svg>` 元素。但是所使用的命名空间需要先在 `d3.namespaces` 中进行注册，D3 内置的已注册的命名空间如下：

  ```js
  {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  }
  ```

  ```js
  // 注册一个新的命名空间
  d3.namespaces.newspace = "https://benbinbin.github.io/"
  ```

* `selection.classed(names[, value])` 为选择集中的元素设置 CSS 的类属性，其中第二个可选参数是布尔值，用以控制在 `class` 中添加还是移除 `name`

  :bulb: 参数 `name` 可以是包含多个类名，它们**用空格分隔**

  ```js
  // 在选择集的元素的类属性中添加 foo 和 bar 类名
  selection.classed("foo bar", true)
  ```

  :bulb: 参数 `value` 也可以是一个返回布尔值的函数，元素分别调用该函数，并依次传入三个参数

  :bulb: 如果调用该方法时，没有传入可选参数 `value` 则基于选择集的第一个非空元素是否具有 `name` 类名的情况，返回一个布尔值。这种用法一般适用于选择集中只有一个元素的情况，可以方便地了解特定的类名是否在相应的元素上。

* `selection.style(name[, value[, priority]])` 为选择集中的元素设置样式。其中第三个可选参数是用以设置新增的样式的**优先级**，默认值是 `null`，还可以设置为 `import`（没有感叹号 `!`）以为新增的样式赋予最高优先级

  :bulb: 参数 `value` 也可以是一个返回样式属性值的函数，元素分别调用该函数，并依次传入三个参数

  :bulb: 如果参数 `value` 的值是 `null` 则会移除元素的 `name` 样式

  :bulb: 如果调用该方法时，没有传入可选参数 `value` 则返回选择集的第一个元素的样式 `name` 的值

  :warning: CSS 的一些样式值应该带**单位**才有效，如设置宽度时 `3px`

* `selection.property(name[, value])` 为选择集中的元素添加值为 `value` 名字为 `name` 的属性。

  :bulb: 一般和 `selection.attr()` 方法通用，但是对于一个节点的属性，没有对应的标签属性，只能使用该方法，例如文本框的 `value` 属性，复选框的 `checked` 属性

  :bulb: 参数 `value` 也可以是一个返回属性值的函数，元素分别调用该函数，并依次传入三个参数

  :bulb: 如果参数 `value` 的值是 `null` 则会移除元素的 `name` 属性

  :bulb: 如果调用该方法时，没有传入可选参数 `value` 则返回选择集的第一个元素的属性 `name` 的属性值

除了设置元素的属性样式，选择集还提供了方法设置元素的内容：

* `selection.text([value])` 为选择集中的元素设置文本内容，即把元素的 innerText 设置为参数 `value`

  :bulb: 参数 `value` 也可以是一个返回文本内容的函数，元素分别调用该函数，并依次传入三个参数

  :bulb: 如果调用该方法时，没有传入可选参数 `value` 则返回选择集的第一个元素的文本内容

* `selection.html([value])` 为选择集中的元素设置 innerHTML 该方法一般仅用于为元素内部设置小片段的 HTML 内容（富文本内容）

  :bulb: 该方法只适用于选择集中的元素是 HTML 元素，而不能是 SVG 元素

  :bulb: 如果希望在元素内增添其他元素，可以使用方法 `selection.append()` 或 `selection.insert()` 这些方法还可以从父元素继承数据，实现数据驱动生成指定的内容 data-driven content

## 增删元素
选择集除了可以设置页面原有的元素，还有方法为页面增删元素：

* `selection.append(type)` 一般用于在选择集（各分组）的各元素内添加一个子元素，其中 `type` 是指 HTML 或 SVG 的标签名称，该新增的元素作为最后一个子元素。该方法最后返回的也是一个包含所有新增元素的选择集，便于后续进行**链式**调用。

  :bulb: 参数 `type` 可以是一个返回一个元素的函数，选择集的元素会分别调用该方法，并依次传入三个参数：
    * 当前所遍历的元素所绑定的数据 datum `d`
    * 当前所遍历的元素在其分组中的索引 index `i`
    * 当前所遍历的元素其所属分组的所有元素 `nodes`

    而函数内的 `this` 指向当前遍历的元素，即 `nodes[i]`

  ```js
  d3.selectAll("div").append(() => document.createElement("p"));
  ```

  函数的返回值也可以是一个已存在节点，其效果一样

  ```js
  // 和上一个代码片段作用一样
  d3.selectAll("div").select(function() {
    return this.appendChild(document.createElement("p"));
  });
  ```

  :bulb: 由于该操作是在元素内仅插入**一个子元素**，所以会类似 `selection.select()` 方法一样，[**继承**其父元素所绑定的数据](https://codepen.io/benbinbin/pen/abLwmXL)（假如父元素有绑定的数据，即元素具有属性 `__data__`）

  ![selection-append-data-inherited](./images/selection-append-data-inherited.gif)

  :bulb: 如果 `selection` 是 entering 选择集，因为选择集在绑定数据时，元素和数据的数量并不一定一一对应，当一些数据多出来时，即无法在当前页面的找到元素与之匹配，所以会先使用占位符 placeholder 来表示，这些「虚拟节点」构成了 entering 选择集。然后[使用该方法将这些虚拟节点添加到页面上](https://codepen.io/benbinbin/pen/yLzXJNE)，**这些新增的元素和 updating 选择集的元素是兄弟元素的关系**，它们的顺序与所绑定的数据**在其数组中的顺序一样**。

  ![entering-append](./images/entering-append.png)

  *但是对于 updating 选择集中的元素，如果在新绑定的数组中，它们所对应的数据的索引发生了变化时，页面的相应元素的次序并不会更新，因为它们是可复用的一些元素，需要手动调用 `selection.order()` 来重排元素以刷新。*

* `selection.insert(type[, beforeSelector ])` 用于在选择集的各元素内添加一个子元素，与方法 `selection.append()` 类似，但它更通用因为第二个参数 `beforeSelector` 是一个 CSS 选择器来设定新增的子元素的放置在任意的位置，该可选参数 `beforeSelector` 的默认值是 `null` 其效果和方法 `selection.append()` 一样。该方法最后返回的也是一个包含所有新增元素的选择集，便于后续进行**链式**调用。

  ```js
  d3.selectAll("div").insert("p");
  ```

  如果设置为 `:first-child` 则新增的子元素会在原来元素的第一个子元素**之前**，即最后新增 prepend 的元素会作为第一个子元素。

  :bulb: 参数 `type` 和 `beforeSelector` 都可以是一个函数，它们分别返回一个将要插入到页面的子元素，和一个作为定位参考的子元素（新增的子元素会被添加到该元素前）

  ```js
  // 和上一个代码片段作用一样
  d3.selectAll("div").insert(() => document.createElement("p"));
  ```

  :bulb: 新增的子元素也是会继承其父元素所绑定的数据（假如父元素有绑定的数据）

* `selection.clone([deep])` 用以拷贝选择集的元素，即在页面上，在选择集的每个元素后添加它的拷贝。其中**当可选参数 `deep` 为 truthy 真时，该元素的[所有后代元素都会被拷贝](https://codepen.io/benbinbin/pen/WNZOOqa)**；否则就只会拷贝元素标签本身（不包含其子元素，甚至也不包含其文本内容）。最后该方法返回一个包含新增到页面的所有拷贝的新选择集，便于后续进行**链式**调用。

  ![selection-clone](./images/selection-clone.png)

* `selection.remove()` 将选择集中的元素从页面移除，一般用在 exiting 选择集。该方法最后依然返回该选择集，其中包含的元素都已经从页面移除

  因为选择集在绑定数据时，元素和数据的数量并不一定一一对应，当选择集中的元素在新数组中没有相匹配的数据（一般使用了 key 函数来进行数据与元素的匹配），它们被划分到 exiting 选择集，然后使用方法 `selection.remove()` 将它们从页面移除

  :bulb: D3 目前还没有提供一个 API 把已移除的元素添加回页面，可以先使用变量存储 `selection.remove()` 返回的选择集，然后使用 `selection.append()` 或 `selection.insert()` 等方法将它们添加回页面中。

## 绑定数据
很多时候，数据多于页面目标元素，则选择器会使用占位符 placeholder 来代替，类似于虚拟的 DOM 元素来表示（即将要添加到页面）与相应数据匹配的 DOM 元素